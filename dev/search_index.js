var documenterSearchIndex = {"docs":
[{"location":"#SymbolicLimits.jl","page":"Home","title":"SymbolicLimits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymbolicLimits.jl is a Julia package for computing symbolic limits using the Gruntz algorithm. It provides robust limit computation for complex symbolic expressions involving exponentials, logarithms, and algebraic operations.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computing symbolic limits is a fundamental operation in symbolic mathematics, but it's also computationally challenging. Zero equivalence of log-exp functions is undecidable and reducible to computing symbolic limits. SymbolicLimits.jl implements the Gruntz algorithm to handle this complexity by using a heuristic zero-equivalence detector and tracking all assumptions made during computation.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Robust Limit Computation: Handles complex expressions involving exponentials and logarithms\nAssumption Tracking: Returns both the limit result and the assumptions required for correctness\nGruntz Algorithm: Implements the state-of-the-art algorithm for symbolic limits\nDirection Support: Supports left-sided, right-sided, and two-sided limits","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SymbolicLimits, SymbolicUtils\n\n@syms x::Real\n\n# Basic limits\nlimit(exp(x+exp(-x))-exp(x), x, Inf)\nlimit(-1/x, x, Inf)\nlimit(-x / log(x), x, Inf)","category":"page"},{"location":"#Limitations-and-Assumptions","page":"Home","title":"Limitations and Assumptions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since zero equivalence is undecidable, SymbolicLimits uses heuristics and tracks assumptions. The returned result is correct if all tracked assumptions hold. In practice, the heuristics are reliable for most mathematical expressions encountered in typical use cases.","category":"page"},{"location":"#Algorithm-Background","page":"Home","title":"Algorithm Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package implements the Gruntz algorithm (1996), which handles limits by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finding most rapidly varying subexpressions (MRV sets)\nRewriting expressions in terms of distinguished subexpressions  \nComputing series expansions around the most varying terms\nExtracting leading coefficients and exponents","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#SymbolicLimits.compare_variance_rapidity-NTuple{4, Any}","page":"Home","title":"SymbolicLimits.compare_variance_rapidity","text":"compare_variance_rapidity(expr1, expr2, x, assumptions)\n\nCompare the rapidity of growth between two expressions as x approaches infinity.\n\nReturns:\n\n-1 if expr1 grows slower than expr2 (i.e., expr1 ≺ expr2)\n0 if expr1 and expr2 grow at the same rate (i.e., expr1 ≍ expr2)\n1 if expr1 grows faster than expr2 (i.e., expr1 ≻ expr2)\n\nThe comparison is based on the limit of log(expr1)/log(expr2) as x approaches infinity:\n\nf ≺ g iff log(f)/log(g) → 0\nf ≍ g iff log(f)/log(g) → c for some finite nonzero constant c\nf ≻ g iff log(f)/log(g) → ∞\n\nArguments\n\nexpr1, expr2: Expressions to compare (must be of the form x or exp(...)).\nx: The variable approaching infinity\nassumptions: A set to track assumptions made during computation\n\nReturns\n\nAn integer (-1, 0, or 1) indicating the relative growth rates.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.get_leading_exponent-Union{Tuple{T}, Tuple{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, Any, Any}} where T","page":"Home","title":"SymbolicLimits.get_leading_exponent","text":"get_leading_exponent(expr, ω, h, assumptions)\n\nFind the leading (smallest) exponent in the series expansion of expr in powers of ω.\n\nThis function determines the power of the leading term in the series expansion: expr = c_{e}⋅ω^e + c_{e+1}⋅ω^{e+1} + ... where e is the leading exponent (the smallest exponent with a non-zero coefficient).\n\nReturns Inf if expr is equivalent to zero.\n\nArguments\n\nexpr: The expression to analyze\nω: A symbol representing the distinguished exponential exp(h)\nh: The argument of the distinguished exponential\nassumptions: A set to track assumptions made during computation\n\nReturns\n\nThe leading exponent e, or Inf if expr is equivalent to zero.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.get_series_term-Union{Tuple{T}, Tuple{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, Any, Int64, Any}} where T","page":"Home","title":"SymbolicLimits.get_series_term","text":"get_series_term(expr, ω, h, i, assumptions)\n\nGet the coefficient of ω^i in the series expansion of expr around the most rapidly varying term.\n\nThis function computes the i-th coefficient in the series expansion of expr in powers of ω, where ω represents the expression exp(h). The expansion takes the form: expr = c₀ + c₁⋅ω + c₂⋅ω² + ...\n\nThis is a core component of the Gruntz algorithm for computing limits.\n\nArguments\n\nexpr: The expression to expand\nω: A symbol representing the distinguished exponential exp(h)\nh: The argument of the distinguished exponential\ni: The power of ω for which to compute the coefficient\nassumptions: A set to track assumptions made during computation\n\nReturns\n\nThe coefficient of ω^i in the series expansion of expr.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.is_exp-Tuple{Any}","page":"Home","title":"SymbolicLimits.is_exp","text":"is_exp(expr)\n\nCheck if an expression is of the form exp(...).\n\nReturns true if expr is a symbolic expression with the exponential function as its operation, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.limit","page":"Home","title":"SymbolicLimits.limit","text":"limit(expr, var, h[, side::Symbol])\n\nCompute the limit of expr as var approaches h and return (limit, assumptions). If all the assumptions are true, then the returned limit is correct.\n\nside indicates the direction from which var approaches h. It may be one of :left, :right, or :both. If side is :both and the two sides do not align, an error is thrown. Side defaults to :both for finite h, :left for h = Inf, and :right for h = -Inf.\n\n\n\n\n\n","category":"function"},{"location":"#SymbolicLimits.limit_inf-Tuple{Any, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T}","page":"Home","title":"SymbolicLimits.limit_inf","text":"limit_inf(expr, x)\n\nCompute the limit of expr as x approaches infinity and return (limit, assumptions).\n\nThis is the internal API boundary between the internal limits.jl file and the public SymbolicLimits.jl file\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.log_exp_simplify-Tuple{Any}","page":"Home","title":"SymbolicLimits.log_exp_simplify","text":"log_exp_simplify(expr)\n\nSimplify expressions by canceling log(exp(x)) → x transformations.\n\nThis function performs basic log-exp simplifications that are always valid, specifically canceling log(exp(x)) to x. This is a conservative simplification that doesn't extend domains.\n\nArguments\n\nexpr: The expression to simplify\n\nReturns\n\nThe simplified expression with log-exp cancellations applied.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.most_rapidly_varying_subexpressions-Union{Tuple{T}, Tuple{Field}, Tuple{Field, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, Any}} where {Field, T}","page":"Home","title":"SymbolicLimits.most_rapidly_varying_subexpressions","text":"most_rapidly_varying_subexpressions(expr, x, assumptions)\n\nFind the most rapidly varying subexpressions (MRV set) in expr with respect to x.\n\nThe MRV set consists of subexpressions that grow most rapidly as x approaches infinity. This is a key component of the Gruntz algorithm for computing symbolic limits.\n\nFor scalar expressions, returns an empty list.\n\nArguments\n\nexpr: The expression to analyze\nx: The variable with respect to which we find rapidly varying subexpressions\nassumptions: A set to track assumptions made during computation\n\nReturns\n\nA list of the most rapidly varying subexpressions in expr.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.recursive-Tuple{Any, Vararg{Any}}","page":"Home","title":"SymbolicLimits.recursive","text":"recursive(f, args...)\n\nApply function f recursively to its arguments, where f takes the recursive function as its first argument.\n\nThis utility function enables recursive operations on nested expressions by passing the recursive function itself as the first argument to f.\n\nExample\n\nrecursive(expr) do f, ex\n    # f is the recursive function, ex is the current expression\n    # Apply f to subexpressions and build the result\nend\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.rewrite-Union{Tuple{T}, Tuple{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}, Any}} where T","page":"Home","title":"SymbolicLimits.rewrite","text":"rewrite(expr, ω, h, x, assumptions)\n\nRewrite expr in the form A⋅ω^c where A is less rapidly varying than ω and c is a real number.\n\nThis function takes an exponential expression and rewrites it in terms of a distinguished exponential subexpression ω. The symbol ω represents exp(h) where h is the argument of the most rapidly varying exponential.\n\nThe rewriting follows the formula: if expr = exp(s) and ω = exp(h), then we compute c = lim(s/h, x, ∞) and rewrite as exp(s-c⋅h) ⋅ ω^c.\n\nArguments\n\nexpr: An exponential expression to rewrite (must be of the form exp(...))\nω: A symbol representing the distinguished exponential exp(h)\nh: The argument of the distinguished exponential\nx: The variable approaching infinity\nassumptions: A set to track assumptions made during computation\n\nReturns\n\nAn expression of the form A⋅ω^c where A is less rapidly varying than ω.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.signed_limit_inf-Union{Tuple{Field}, Tuple{Field, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T, Any}} where Field","page":"Home","title":"SymbolicLimits.signed_limit_inf","text":"signed_limit_inf(expr, x, assumptions)\n\nCompute the limit of expr as x approaches infinity and return (limit, sign). This function handles both symbolic expressions and scalar values, tracking assumptions made during the computation.\n\nFor scalar expressions, returns (expr, sign(expr)). For symbolic expressions, applies the Gruntz algorithm to compute the limit.\n\nArguments\n\nexpr: The expression to take the limit of\nx: The variable approaching infinity\nassumptions: A set to track assumptions made during computation\n\nReturns\n\nA tuple (limit, sign) where:\n\nlimit: The computed limit value\nsign: The sign of the limit\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.strong_log_exp_simplify-Tuple{Any}","page":"Home","title":"SymbolicLimits.strong_log_exp_simplify","text":"cancels log(exp(x)) and exp(log(x)), the latter may extend the domain\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicLimits.zero_equivalence-Tuple{Any, Any}","page":"Home","title":"SymbolicLimits.zero_equivalence","text":"zero_equivalence(expr, assumptions)\n\nDetermine if expr is equivalent to zero on its domain using heuristic methods.\n\nThis function uses symbolic simplification to determine if an expression is zero. Since zero equivalence of general expressions is undecidable, this function uses heuristics and records the result as an assumption that must hold for the computed limit to be correct.\n\nThe function applies strong log-exp simplification and algebraic expansion before testing for zero equivalence.\n\nArguments\n\nexpr: The expression to test for zero equivalence\nassumptions: A set to record assumptions made (updated in-place)\n\nReturns\n\ntrue if the expression is determined to be zero, false otherwise.\n\nSide Effects\n\nAdds an assumption about the zero-equivalence of expr to the assumptions set.\n\n\n\n\n\n","category":"method"}]
}

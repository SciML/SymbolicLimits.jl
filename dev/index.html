<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SymbolicLimits.jl</title><meta name="title" content="Home · SymbolicLimits.jl"/><meta property="og:title" content="Home · SymbolicLimits.jl"/><meta property="twitter:title" content="Home · SymbolicLimits.jl"/><meta name="description" content="Documentation for SymbolicLimits.jl."/><meta property="og:description" content="Documentation for SymbolicLimits.jl."/><meta property="twitter:description" content="Documentation for SymbolicLimits.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SymbolicLimits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Key-Features"><span>Key Features</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Limitations-and-Assumptions"><span>Limitations and Assumptions</span></a></li><li><a class="tocitem" href="#Algorithm-Background"><span>Algorithm Background</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SymbolicLimits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SymbolicLimits.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymbolicLimits.jl"><a class="docs-heading-anchor" href="#SymbolicLimits.jl">SymbolicLimits.jl</a><a id="SymbolicLimits.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicLimits.jl" title="Permalink"></a></h1><p>SymbolicLimits.jl is a Julia package for computing symbolic limits using the Gruntz algorithm. It provides robust limit computation for complex symbolic expressions involving exponentials, logarithms, and algebraic operations.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Computing symbolic limits is a fundamental operation in symbolic mathematics, but it&#39;s also computationally challenging. Zero equivalence of log-exp functions is undecidable and reducible to computing symbolic limits. SymbolicLimits.jl implements the Gruntz algorithm to handle this complexity by using a heuristic zero-equivalence detector and tracking all assumptions made during computation.</p><h2 id="Key-Features"><a class="docs-heading-anchor" href="#Key-Features">Key Features</a><a id="Key-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Features" title="Permalink"></a></h2><ul><li><strong>Robust Limit Computation</strong>: Handles complex expressions involving exponentials and logarithms</li><li><strong>Assumption Tracking</strong>: Returns both the limit result and the assumptions required for correctness</li><li><strong>Gruntz Algorithm</strong>: Implements the state-of-the-art algorithm for symbolic limits</li><li><strong>Direction Support</strong>: Supports left-sided, right-sided, and two-sided limits</li></ul><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">using SymbolicLimits, SymbolicUtils

@syms x::Real

# Basic limits
limit(exp(x+exp(-x))-exp(x), x, Inf)
limit(-1/x, x, Inf)
limit(-x / log(x), x, Inf)</code></pre><h2 id="Limitations-and-Assumptions"><a class="docs-heading-anchor" href="#Limitations-and-Assumptions">Limitations and Assumptions</a><a id="Limitations-and-Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations-and-Assumptions" title="Permalink"></a></h2><p>Since zero equivalence is undecidable, SymbolicLimits uses heuristics and tracks assumptions. The returned result is correct if all tracked assumptions hold. In practice, the heuristics are reliable for most mathematical expressions encountered in typical use cases.</p><h2 id="Algorithm-Background"><a class="docs-heading-anchor" href="#Algorithm-Background">Algorithm Background</a><a id="Algorithm-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Background" title="Permalink"></a></h2><p>The package implements the Gruntz algorithm (1996), which handles limits by:</p><ol><li>Finding most rapidly varying subexpressions (MRV sets)</li><li>Rewriting expressions in terms of distinguished subexpressions  </li><li>Computing series expansions around the most varying terms</li><li>Extracting leading coefficients and exponents</li></ol><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.compare_variance_rapidity-NTuple{4, Any}" href="#SymbolicLimits.compare_variance_rapidity-NTuple{4, Any}"><code>SymbolicLimits.compare_variance_rapidity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_variance_rapidity(expr1, expr2, x, assumptions)</code></pre><p>Compare the rapidity of growth between two expressions as <code>x</code> approaches infinity.</p><p>Returns:</p><ul><li><code>-1</code> if <code>expr1</code> grows slower than <code>expr2</code> (i.e., <code>expr1 ≺ expr2</code>)</li><li><code>0</code> if <code>expr1</code> and <code>expr2</code> grow at the same rate (i.e., <code>expr1 ≍ expr2</code>)</li><li><code>1</code> if <code>expr1</code> grows faster than <code>expr2</code> (i.e., <code>expr1 ≻ expr2</code>)</li></ul><p>The comparison is based on the limit of <code>log(expr1)/log(expr2)</code> as <code>x</code> approaches infinity:</p><ul><li><code>f ≺ g</code> iff <code>log(f)/log(g) → 0</code></li><li><code>f ≍ g</code> iff <code>log(f)/log(g) → c</code> for some finite nonzero constant <code>c</code></li><li><code>f ≻ g</code> iff <code>log(f)/log(g) → ∞</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>expr1</code>, <code>expr2</code>: Expressions to compare (must be of the form <code>x</code> or <code>exp(...)</code>).</li><li><code>x</code>: The variable approaching infinity</li><li><code>assumptions</code>: A set to track assumptions made during computation</li></ul><p><strong>Returns</strong></p><p>An integer (-1, 0, or 1) indicating the relative growth rates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L302-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.get_leading_exponent-Union{Tuple{Field}, Tuple{SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, Any, Any}} where Field" href="#SymbolicLimits.get_leading_exponent-Union{Tuple{Field}, Tuple{SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, Any, Any}} where Field"><code>SymbolicLimits.get_leading_exponent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_leading_exponent(expr, ω, h, assumptions)</code></pre><p>Find the leading (smallest) exponent in the series expansion of <code>expr</code> in powers of <code>ω</code>.</p><p>This function determines the power of the leading term in the series expansion: <code>expr = c_{e}⋅ω^e + c_{e+1}⋅ω^{e+1} + ...</code> where <code>e</code> is the leading exponent (the smallest exponent with a non-zero coefficient).</p><p>Returns <code>Inf</code> if <code>expr</code> is equivalent to zero.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to analyze</li><li><code>ω</code>: A symbol representing the distinguished exponential <code>exp(h)</code></li><li><code>h</code>: The argument of the distinguished exponential</li><li><code>assumptions</code>: A set to track assumptions made during computation</li></ul><p><strong>Returns</strong></p><p>The leading exponent <code>e</code>, or <code>Inf</code> if <code>expr</code> is equivalent to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L558-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.get_series_term-Union{Tuple{Field}, Tuple{SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, Any, Int64, Any}} where Field" href="#SymbolicLimits.get_series_term-Union{Tuple{Field}, Tuple{SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, Any, Int64, Any}} where Field"><code>SymbolicLimits.get_series_term</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_series_term(expr, ω, h, i, assumptions)</code></pre><p>Get the coefficient of <code>ω^i</code> in the series expansion of <code>expr</code> around the most rapidly varying term.</p><p>This function computes the <code>i</code>-th coefficient in the series expansion of <code>expr</code> in powers of <code>ω</code>, where <code>ω</code> represents the expression <code>exp(h)</code>. The expansion takes the form: <code>expr = c₀ + c₁⋅ω + c₂⋅ω² + ...</code></p><p>This is a core component of the Gruntz algorithm for computing limits.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to expand</li><li><code>ω</code>: A symbol representing the distinguished exponential <code>exp(h)</code></li><li><code>h</code>: The argument of the distinguished exponential</li><li><code>i</code>: The power of <code>ω</code> for which to compute the coefficient</li><li><code>assumptions</code>: A set to track assumptions made during computation</li></ul><p><strong>Returns</strong></p><p>The coefficient of <code>ω^i</code> in the series expansion of <code>expr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L409-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.is_exp-Tuple{Any}" href="#SymbolicLimits.is_exp-Tuple{Any}"><code>SymbolicLimits.is_exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_exp(expr)</code></pre><p>Check if an expression is of the form <code>exp(...)</code>.</p><p>Returns <code>true</code> if <code>expr</code> is a symbolic expression with the exponential function as its operation, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.limit" href="#SymbolicLimits.limit"><code>SymbolicLimits.limit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limit(expr, var, h[, side::Symbol])</code></pre><p>Compute the limit of <code>expr</code> as <code>var</code> approaches <code>h</code> and return <code>(limit, assumptions)</code>. If all the <code>assumptions</code> are true, then the returned <code>limit</code> is correct.</p><p><code>side</code> indicates the direction from which <code>var</code> approaches <code>h</code>. It may be one of <code>:left</code>, <code>:right</code>, or <code>:both</code>. If <code>side</code> is <code>:both</code> and the two sides do not align, an error is thrown. Side defaults to <code>:both</code> for finite <code>h</code>, <code>:left</code> for <code>h = Inf</code>, and <code>:right</code> for <code>h = -Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/SymbolicLimits.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.limit_inf-Union{Tuple{Field}, Tuple{Any, SymbolicUtils.BasicSymbolic{Field}}} where Field" href="#SymbolicLimits.limit_inf-Union{Tuple{Field}, Tuple{Any, SymbolicUtils.BasicSymbolic{Field}}} where Field"><code>SymbolicLimits.limit_inf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limit_inf(expr, x)</code></pre><p>Compute the limit of <code>expr</code> as <code>x</code> approaches infinity and return <code>(limit, assumptions)</code>.</p><p>This is the internal API boundary between the internal limits.jl file and the public SymbolicLimits.jl file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.log_exp_simplify-Tuple{Any}" href="#SymbolicLimits.log_exp_simplify-Tuple{Any}"><code>SymbolicLimits.log_exp_simplify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log_exp_simplify(expr)</code></pre><p>Simplify expressions by canceling <code>log(exp(x))</code> → <code>x</code> transformations.</p><p>This function performs basic log-exp simplifications that are always valid, specifically canceling <code>log(exp(x))</code> to <code>x</code>. This is a conservative simplification that doesn&#39;t extend domains.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to simplify</li></ul><p><strong>Returns</strong></p><p>The simplified expression with log-exp cancellations applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.most_rapidly_varying_subexpressions-Union{Tuple{Field}, Tuple{Field, SymbolicUtils.BasicSymbolic{Field}, Any}} where Field" href="#SymbolicLimits.most_rapidly_varying_subexpressions-Union{Tuple{Field}, Tuple{Field, SymbolicUtils.BasicSymbolic{Field}, Any}} where Field"><code>SymbolicLimits.most_rapidly_varying_subexpressions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">most_rapidly_varying_subexpressions(expr, x, assumptions)</code></pre><p>Find the most rapidly varying subexpressions (MRV set) in <code>expr</code> with respect to <code>x</code>.</p><p>The MRV set consists of subexpressions that grow most rapidly as <code>x</code> approaches infinity. This is a key component of the Gruntz algorithm for computing symbolic limits.</p><p>For scalar expressions, returns an empty list.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to analyze</li><li><code>x</code>: The variable with respect to which we find rapidly varying subexpressions</li><li><code>assumptions</code>: A set to track assumptions made during computation</li></ul><p><strong>Returns</strong></p><p>A list of the most rapidly varying subexpressions in <code>expr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L229-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.recursive-Tuple{Any, Vararg{Any}}" href="#SymbolicLimits.recursive-Tuple{Any, Vararg{Any}}"><code>SymbolicLimits.recursive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">recursive(f, args...)</code></pre><p>Apply function <code>f</code> recursively to its arguments, where <code>f</code> takes the recursive function as its first argument.</p><p>This utility function enables recursive operations on nested expressions by passing the recursive function itself as the first argument to <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">recursive(expr) do f, ex
    # f is the recursive function, ex is the current expression
    # Apply f to subexpressions and build the result
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L164-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.rewrite-Union{Tuple{Field}, Tuple{SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, Any}} where Field" href="#SymbolicLimits.rewrite-Union{Tuple{Field}, Tuple{SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, SymbolicUtils.BasicSymbolic{Field}, Any}} where Field"><code>SymbolicLimits.rewrite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite(expr, ω, h, x, assumptions)</code></pre><p>Rewrite <code>expr</code> in the form <code>A⋅ω^c</code> where <code>A</code> is less rapidly varying than <code>ω</code> and <code>c</code> is a real number.</p><p>This function takes an exponential expression and rewrites it in terms of a distinguished exponential subexpression <code>ω</code>. The symbol <code>ω</code> represents <code>exp(h)</code> where <code>h</code> is the argument of the most rapidly varying exponential.</p><p>The rewriting follows the formula: if <code>expr = exp(s)</code> and <code>ω = exp(h)</code>, then we compute <code>c = lim(s/h, x, ∞)</code> and rewrite as <code>exp(s-c⋅h) ⋅ ω^c</code>.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: An exponential expression to rewrite (must be of the form <code>exp(...)</code>)</li><li><code>ω</code>: A symbol representing the distinguished exponential <code>exp(h)</code></li><li><code>h</code>: The argument of the distinguished exponential</li><li><code>x</code>: The variable approaching infinity</li><li><code>assumptions</code>: A set to track assumptions made during computation</li></ul><p><strong>Returns</strong></p><p>An expression of the form <code>A⋅ω^c</code> where <code>A</code> is less rapidly varying than <code>ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L372-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.signed_limit_inf-Union{Tuple{Field}, Tuple{Field, SymbolicUtils.BasicSymbolic{Field}, Any}} where Field" href="#SymbolicLimits.signed_limit_inf-Union{Tuple{Field}, Tuple{Field, SymbolicUtils.BasicSymbolic{Field}, Any}} where Field"><code>SymbolicLimits.signed_limit_inf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">signed_limit_inf(expr, x, assumptions)</code></pre><p>Compute the limit of <code>expr</code> as <code>x</code> approaches infinity and return <code>(limit, sign)</code>. This function handles both symbolic expressions and scalar values, tracking assumptions made during the computation.</p><p>For scalar expressions, returns <code>(expr, sign(expr))</code>. For symbolic expressions, applies the Gruntz algorithm to compute the limit.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to take the limit of</li><li><code>x</code>: The variable approaching infinity</li><li><code>assumptions</code>: A set to track assumptions made during computation</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(limit, sign)</code> where:</p><ul><li><code>limit</code>: The computed limit value</li><li><code>sign</code>: The sign of the limit</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L75-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.strong_log_exp_simplify-Tuple{Any}" href="#SymbolicLimits.strong_log_exp_simplify-Tuple{Any}"><code>SymbolicLimits.strong_log_exp_simplify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>cancels log(exp(x)) and exp(log(x)), the latter may extend the domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L214-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicLimits.zero_equivalence-Tuple{Any, Any}" href="#SymbolicLimits.zero_equivalence-Tuple{Any, Any}"><code>SymbolicLimits.zero_equivalence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_equivalence(expr, assumptions)</code></pre><p>Determine if <code>expr</code> is equivalent to zero on its domain using heuristic methods.</p><p>This function uses symbolic simplification to determine if an expression is zero. Since zero equivalence of general expressions is undecidable, this function uses heuristics and records the result as an assumption that must hold for the computed limit to be correct.</p><p>The function applies strong log-exp simplification and algebraic expansion before testing for zero equivalence.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to test for zero equivalence</li><li><code>assumptions</code>: A set to record assumptions made (updated in-place)</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the expression is determined to be zero, <code>false</code> otherwise.</p><p><strong>Side Effects</strong></p><p>Adds an assumption about the zero-equivalence of <code>expr</code> to the <code>assumptions</code> set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicLimits.jl/blob/aeb0a5aeaae64455ca3e96f1156408b9eab9ef04/src/limits.jl#L659-L683">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 11 September 2025 12:19">Thursday 11 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
